#### 类型推论

即类型是在哪里如何被推断的

- 基础类型

在初始化变量和成员，设置默认参数值和决定函数返回值时，有些没有明确指出类型的地方，类型推论会帮助提供类型

```ts
// 变量x的类型被推断为数字
let x = 3;
```

- 最佳通用类型

当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型

```ts
// 变量x的类型被推断为(number | null)[]
let x = [0, 1, null];
```

如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型

```ts
// 变量x的类型被推断为(Rhino | Elephant | Snake)[]
let zoo = [new Rhino(), new Elephant(), new Snake()];
```

- 上下文类型

类型推论也可能按照相反的方向进行，发生在表达式的类型与所处的位置相关时

```ts
window.onmousedown = function(mouseEvent) {
    console.log(mouseEvent.button);  // 错误
};
```

类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型，如果函数表达式不是在上下文类型的位置， mouseEvent参数的类型需要指定为any，这样也不会报错了

```ts
window.onmousedown = function(mouseEvent: any) {
    console.log(mouseEvent.button);  // 正确
};
```

#### 类型兼容

TypeScript里的类型兼容性是基于结构类型的，结构类型是一种只使用其成员来描述类型的方式

- 对象

如果x要兼容y，那么y至少具有与x相同的属性

```ts
interface Named {
    name: string;
}

let x: Named;
let y = { name: 'Alice', location: 'Seattle' };
x = y;
```

- 函数

如果x要兼容y，y的每个参数必须能在x里找到对应类型的参数，类型相同即可，参数名可以不同

```ts
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x; // OK
x = y; // Error
```

源函数的返回值类型必须是目标函数返回值类型的子类型

```ts
let x = () => ({name: 'Alice'});
let y = () => ({name: 'Alice', location: 'Seattle'});

x = y; // OK
y = x; // Error, because x() lacks a location property
```

源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误

```ts
function invokeLater(args: any[], callback: (...args: any[]) => void) {
    /* ... Invoke callback with 'args' ... */
}

// Unsound - invokeLater "might" provide any number of arguments
invokeLater([1, 2], (x, y) => console.log(x + ', ' + y));

// Confusing (x and y are actually required) and undiscoverable
invokeLater([1, 2], (x?, y?) => console.log(x + ', ' + y));
```

- 枚举

枚举类型与数字类型兼容，并且数字类型与枚举类型兼容，不同枚举类型之间是不兼容的

```ts
enum Status { Ready, Waiting };
enum Color { Red, Blue, Green };

let status = Status.Ready;
status = 3; // 正确
status = Color.Green; // 错误
```

- 类

两个类类型的对象时，只有实例的成员会被比较，静态成员和构造函数不在比较的范围内

```ts
class Animal {
    feet: number = 1;
    constructor(name: string, numFeet?: number) { }
}

class Size {
    feet: number = 1;
    constructor(numFeet: number) { }
}

let a: Animal;
let s: Size;

a = s;  // OK
s = a;  // OK
```

类的private和protected成员会影响兼容性，当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员

- 泛型

类型参数只影响使用其做为类型一部分的结果类型，表现如下

```ts
interface Empty<T> {
}
let x1: Empty<number>;
let y1: Empty<string>;
x1 = y1; // 正确

interface NotEmpty<T> {
    data: T;
}
let x2: NotEmpty<number>;
let y2: NotEmpty<string>;
x2 = y2; // 错误
```

对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较

```ts
let identity = function<T>(x: T): T {
    // ...
}
let reverse = function<U>(y: U): U {
    // ...
}
identity = reverse;  // OK, because (x: any) => any matches (y: any) => any
```
