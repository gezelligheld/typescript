#### 交叉类型

将多个类型合并为一个类型，使用&连接不同的类型

```ts
function extend<T, U>(first: T, second: U): T & U {
    let result = <T & U>{};
    for (let id in first) {
        (<any>result)[id] = (<any>first)[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            (<any>result)[id] = (<any>second)[id];
        }
    }
    return result;
}
```

#### 联合类型

表示一个值可以是几种类型之一，使用|分隔不同的类型

```ts
function padLeft(value: string, padding: string | number) {
    // ...
}
```

如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员

```ts
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // 正确
pet.swim();    // 错误，非公有成员
```

#### 有条件的类型

有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一

```ts
// 若T能够赋值给U，那么类型是X，否则为Y
T extends U ? X : Y
```

#### 类型区分和类型保护

接上，当操作该函数的返回值时，无法得知具体时Bird还是Fish类型

```ts
let pet = getSmallPet();

// 每一个成员访问都会报错
if (pet.swim) {
    pet.swim();
}
```

可以加类型断言，告诉编译器已经做过判断了

```ts
let pet = getSmallPet();

if ((<Fish>pet).swim) {
    (pet as Fish).swim();
}
```

- 自定义类型保护

但是这样如果有别的地方也有对返回值的操作，就不得不使用多次断言，类型保护机制会在运行时检查以确保在某个作用域里的类型，无需再添加断言

要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词

```ts
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
```

其中pet is Fish就是类型谓词。 谓词为 parameterName is Type这种形式，parameterName必须是来自于当前函数签名里的一个参数名

- typeof类型保护

typeof类型保护只有两种形式能被识别：typeof v === "typename"和 typeof v !== "typename"，其中typename必须是number、string、boolean或symbol

```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```

> typeof a相当于取a的类型

- instanceof类型保护

通过构造函数来细化类型的一种方式

```ts
if (padder instanceof SpaceRepeatingPadder) {
    padder; // 类型细化为'SpaceRepeatingPadder'
}
```

- null和undefined

类型检查器认为 null与 undefined可以赋值给任何类型。如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加 ! 后缀： identifier!从 identifier的类型里去除了 null和 undefined

```ts
function fixed(name: string | null): string {
  function postfix(epithet: string) {
    // return name.charAt(0) + '.  the ' + epithet; // 错误
    return name!.charAt(0) + '.  the ' + epithet; // 正确
  }
  name = name || "Bob";
  return postfix("great");
}
```

#### 类型别名

如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名

- 使用关键字type声明一个类型别名

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
}
```

- 类型别名也可以是泛型，可以添加类型参数并且在别名声明的右侧传入

```ts
type Container<T> = { value: T };
```

- 可以使用类型别名来在属性里引用自己

```
type Yikes = Array<Yikes>;
```

#### 接口和类型别名的区别

##### 相同点

1. 都可以描述一个对象或者函数

```ts
// interface
interface User {
    name: string
    age: number
}
interface SetUser {
    (name: string, age: number): void;
}

// type
type User = {
   name: string
   age: number
};
type SetUser = (name: string, age: number): void;
```

##### 不同点

1. 都允许拓展和被拓展，interface拓展用extends语法，type拓展用交叉类型&

```ts
// interface extends interface
interface Name {
    name: string;
}
interface User extends Name {
    age: number;
}

// interface extends type
type Name = {
    name: string;
}
interface User extends Name {
    age: number;
}

// type "extends" type  只能用的是交叉类型
type Name = {
    name: string;
}
type User = Name & {age: number};

// type extends interface
interface Name {
    name: string;
}
type User = Name & {
    age: number;
}
```

2. type 可以声明基本类型别名，联合类型，元组等类型

3. type 语句中还可以使用 typeof 获取实例的 类型进行赋值

4. interface 能够声明合并

#### 索引类型

能够检查使用了动态属性名的代码，如下，编译器会自动检查是否会传入了正确的属性名给pluck

```ts
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}
```

- 索引类型查询操作符

keyof是索引类型查询操作符，对于任何类型 T，keyof T 的结果为T上已知的公共属性名的联合

```ts
interface Person {
    name: string;
    age: number;
}

let personProps: keyof Person; // 'name' | 'age'
```

> keyof T相当于取T的键值

- 索引访问操作符

T[K]是索引访问操作符，可以在普通的上下文里使用 T[K]，只要确保类型变量 K extends keyof T就可以

```ts
function getProperty<T, K extends keyof T>(o: T, name: K): T[K] {
    return o[name]; // o[name] is of type T[K]
}
```

此外，keyof和T[K]与字符串索引签名进行交互

```ts
interface Map<T> {
    [key: string]: T;
}
let keys: keyof Map<number>; // string
let value: Map<number>['foo']; // number
```

#### 映射类型

提供了从旧类型中创建新类型的一种方式，新类型可以以相同的形式去转换旧类型里的每个属性

```ts
type Keys = 'option1' | 'option2';
type Flags = { [K in Keys]: boolean };

// 相当于
type Flags = {
    option1: boolean;
    option2: boolean;
}
```

具体包含三个部分

- 类型变量 K，它会依次绑定到每个属性
- 字符串字面量联合的 Keys，它包含了要迭代的属性名的集合
- 属性的结果类型

再如，T[P]被包装在 Proxy<T>类里

```ts
type Proxy<T> = {
    get(): T;
    set(value: T): void;
}
type Proxify<T> = {
    [P in keyof T]: Proxy<T[P]>;
}
function proxify<T>(o: T): Proxify<T> {
   // ... wrap proxies ...
}
let proxyProps = proxify(props);
```