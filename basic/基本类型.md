- 一般基础类型的变量不用定义类型，ts可以自己推断出来

```typescript
// 布尔值
let isDone: boolean = false;

// 字符串
let str: string = '1';

// 数字
let num: number = 1;

// 数组
let strArray: string[] = ['1', '2'];
// 或者写作
let strArray: Array<string> = ['1', '2'];
```

- 元组

允许表示一个已知元素数量和类型的数组，各元素的类型不必相同

```typescript
let x: [string, number];
x = ['hello', 2]; // ok
x = [2, 'hello']; // error
```

- any

用于标记在编程阶段还不清楚类型的变量，会跳过静态检查，尽量少用，一面产生意外的错误

```typescript
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false;

let list: any[] = [1, true, "free"];
```

- void

表示没有任何类型，当一个函数没有返回值时返回类型就是void

```typescript
function warnUser(): void {
    console.log("This is my warning message");
}
```

- object

表示非原始类型，也就是除number，string，boolean，bigint，symbol，null或undefined之外的类型

```typescript
function create(o: object): void {}
create({a: 1});
```

- never

never类型表示的是那些永不存在的值的类型

用在方法中表示方法抛出异常或根本就不会有返回值

```typescript
function infiniteLoop(): never {
    while (true) {}
}
```

用在值中表示从不发生的值的类型

```typescript
type Exclude<T, U> = T extends U ? never : T;

// exclude表示含有
type A = Exclude<'x' | 'a', 'x' | 'y' | 'z'>
const ccc: A = 'x';
```

- null和undefined

- function

如果能够确认函数返回的类型，最好添加上

```typescript
function add(x: number, y: number): number {
    return x + y;
}

let myAddComplete: (baseValue: number, increment: number) => number
    = (x: number, y: number): number => {
    return x + y;
};

// 可简写为
let myAdd = (x: number, y: number): number => {
    return x + y;
};
```

- 枚举

构造一个映射表

```typescript
// 数字枚举
enum Direction {
    Up = 1,
    Down,
    Left,
    Right
}
Direction.Up; // 1
Direction[1]; // 'Up'

// 字符串枚举， 前端的"alias"更加容易语义化，
enum DirectionStr {
    UP = 'up',
    DOWN = 'down',
    LEFT = 'left',
    RIGHT = 'right'
}
let a = DirectionStr.UP; // "up"
let nameOfA = DirectionStr[a]; // 字符串不可以反向映射
```

可以进行常量维护

```typescript
const enum TODO_STATUS {
    TODO = 'TODO',
    DONE = 'DONE',
    DOING = 'DOING'
}

function todos(status: TODO_STATUS): void {};
todos(TODO_STATUS.TODO);
```
