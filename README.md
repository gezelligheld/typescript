# typescript

typescript 总结

- basic 基础
- complie 编译原理
- topic 课题
- example 例子

#### 知识点

##### 为什么使用 typescript

js 是弱类型语言，使用 typescript 可以强制类型，增加代码的可读性和可维护性，在编译阶段就可以避免一些错误

##### 基本类型（boolean、string、number、object、数组、元组、void、any、unknown、never、null、undefined、函数）

void & never：void 类型表示没有任何类型，如一个函数没有返回值；never 类型表示永远不存在的值的类型，如一个函数永远没有返回值或总抛出错误

any & unknown：任何类型的值都能赋值给 any 和 unknown 类型，区别在于 any 会跳过静态检查，unknown 不会，但 unknown 使用时需要做类型检查或类型断言

enum：默认是数字枚举，从 0 开始；字符串枚举不能反向映射

##### 类（公有成员、私有成员、受保护成员、只读成员、抽象类）

public 声明一个公有成员，不写默认为 public，既可以被继承也可以被实例使用；private 声明一个私有成员，即不能被继承也不能被实例使用；protected 声明一个受保护的成员，可以被继承但不能被实例使用

abstract 可以声明一个抽象类，作为其他派生类的基类使用，不能直接被实例化。和接口相比，抽象类可以包含成员的实现细节，其方法必须在子类中实现

##### 接口（函数类型、类类型 implements、索引类型、接口继承、接口继承类）

implements 一个接口后这个类必须拥有接口所描述的 public 成员；接口会继承类的 private 和 protected 成员

##### 泛型（作用、类型变量、泛型约束）

使用泛型可以创建可重用的类型组件，包括接口、类、类型别名等

##### 其他类型（条件类型、交叉类型、联合类型、类型别名 type、type 和 interface 区别、索引类型 keyof、映射类型 in）

条件类型可以简述为 T extends U ? X : Y，如果类型 T 是类型 U 的子集，那么取类型 X，否则取类型 Y。如果 T 是 A | B 这样的联合类型，则会拆解为(A extends U ? X : Y) | (B extends U ? X : Y)，但如果联合类型中含有 never 会被忽略。此外，T extends never 永远不成立，T extends T 可以对类型 T 进行循环遍历。infer 声明的类型变量表示待推断的类型，可以作为条件类型的结果

type & interface：都允许拓展，type 通过交叉类型，interface 通过 extends；interface 重复声明会合并；interface 实际上是创建了一个新的类型，而 type 只是别名；适用场景不同，由于 interface 可合并在编写第三方库或组件时更适用，type 在进行类型计算、封装类型组件时较为适用

keyof 取类型 T 的键的类型；T[K]在满足 K extends keyof T 的前提下可以取某个键对应的值的类型；in 可以迭代类型的键，从而去转换新的类型

##### 命名空间

##### 类型保护

经判断语句后自动收缩为窄类型；关键词 is 可以指定函数的某个参数固定是某一种类型（必须是已声明函数参数类型的子集）

##### 类型推断

ts 可以根据一些规则推断出变量类型，如定义变量、变量赋值、函数的 return 语句

##### 类型兼容（逆变、协变、双向协变、不变）

父类型更加宽泛，子类型更加具体，以此为基础判断一个类型对应的变量是否能够赋值给另外一个变量，即是否类型兼容，简言之如果 y 的类型是 x 的类型的子集，则 y 能赋值给 x，反过来说如果 x 赋值给了 y，y 是更具体的一方，可能存在 x 中没有的实现

当类型 Y 是类型 X 的子集，复合类型 Comp\<Y\>也是类型 Comp\<X\>的子集，即类型 T 和复合类型 Comp\<T\>的类型兼容一致，称为协变，如对象、函数返回类型不同的函数、类的相互之间赋值，需要注意的是类只比较 pbulic 成员且 private、protected 成员需来源于同一个类；当类型 T 和复合类型 Comp\<T\>的类型兼容相反，称为逆变，如函数参数类型不同的函数；既协变又逆变称为双向协变，如一个满足函数参数类型逆变、函数返回值类型协变的函数；既不协变又不逆变称为不变，如一个同时不满足函数参数类型逆变、函数返回值类型协变的函数
